#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)

import copy
import sys
import numpy as np
import os
import itertools
import psutil
from collections import OrderedDict

# must be imported through qtpy before any other gui imports
from qtpy.QtCore import (QProcess, Qt, QUrl)
from qtpy.QtGui import (QDesktopServices, QIcon)
from qtpy import QtGui
from qtpy.QtWidgets import (QApplication, QFileDialog, QMainWindow, QMessageBox, QTableWidgetItem, QVBoxLayout)

from addie import __version__

#import addie.ui_mainWindow
#import addie.ui_table_tree
#import addie.step1
#import addie.step2
from addie.initialization.configuration import ConfigurationInitializer
from addie.utilities.general import get_ucams
from addie.utilities import load_ui

from addie.about import AboutDialog
from addie.menu.file.settings.advanced_file_window import AdvancedWindowLauncher
from addie.menu.file.configuration.export_configuration import ExportConfiguration
from addie.menu.file.configuration.import_configuration import ImportConfiguration

from addie.help_handler.help_gui import HelpGui, help_button_activator

from addie.utilities.job_status_handler import JobStatusHandler
from addie.utilities.job_monitor_thread import JobMonitorThread
from addie.utilities.logbook_thread import LogbookThread
from addie.utilities.logbook_handler import LogbookHandler
from addie.utilities.ipts_file_transfer_dialog import IptsFileTransferDialog

from addie.initialization.init_step1 import InitStep1

from addie.autoNOM.step1_gui_handler import Step1GuiHandler
from addie.autoNOM.run_step1 import RunStep1
from addie.processing.idl.load_table_intermediate_step_interface import loadTableIntermediateStepInterface
from addie.processing.idl.undo_handler import UndoHandler

from addie.initialization.init_step2 import InitStep2
from addie.processing.idl.populate_master_table import PopulateMasterTable
from addie.processing.idl.populate_background_widgets import PopulateBackgroundWidgets
from addie.processing.idl.step2_gui_handler import Step2GuiHandler
from addie.processing.idl.table_handler import TableHandler as IdlTableHandler
from addie.processing.idl.create_sample_files import CreateSampleFiles
from addie.processing.idl.create_ndsum_file import CreateNdsumFile
from addie.processing.idl.run_ndabs import RunNDabs
from addie.processing.idl.run_sum_scans import RunSumScans
from addie.processing.idl.run_thread import RunThread

from addie.menu.preview_ascii.step3_gui_handler import Step3GuiHandler

from addie.mantid_handler.browse_file_folder_handler import BrowseFileFolderHandler
from addie.mantid_handler.mantid_reduction import GlobalMantidReduction
from addie.mantid_handler.mantid_thread import MantidThread

from addie.processing.mantid.master_table.master_table_loader import FromDictionaryToTableUi, AsciiLoader
from addie.processing.mantid.master_table.table_tree_handler import TableTreeHandler, TableInitialization, \
    TableConfig, H3TableHandler
from addie.processing.mantid.master_table.table_tree_handler import SaveConfigInterface, TableTree
from addie.processing.mantid.master_table import *
from addie.processing.mantid.master_table.table_row_handler import TableRowHandler
from addie.processing.mantid.master_table.geometry_handler import DimensionsSetter
from addie.processing.mantid.master_table.selection_handler import TableHandler as MtdTableHandler
from addie.processing.mantid.master_table.reduction_configuration_handler import ReductionConfigurationHandler
from addie.processing.mantid.make_calibration_handler.make_calibration import MakeCalibrationLauncher
from addie.processing.mantid.master_table.periodic_table.material_handler import MaterialHandler
from addie.processing.mantid.master_table.mass_density_handler import MassDensityHandler

try:
    from addie.processing.mantid.master_table.import_from_database.import_from_database_handler import ImportFromDatabaseHandler
    ONCAT_ENABLED = True
except ImportError:
    print('pyoncat module not found. Functionality disabled')
    ONCAT_ENABLED = False

from addie.processing.mantid.master_table.import_from_run_number_handler import ImportFromRunNumberHandler
from addie.processing.mantid.master_table.import_from_database.load_into_master_table import LoadIntoMasterTable

import addie.addiedriver as driver
import addie.utilities.specify_plots_style as ps
import addie.calculate_gr.edit_sq_dialog

from addie.calculate_gr.pdf_lines_manager import PDFPlotManager
from mantidqt.widgets.jupyterconsole import InProcessJupyterConsole

from addie.rietveld.braggview import BraggView
from addie.rietveld.braggtree import BraggTree

from addie.calculate_gr.gofrtree import GofRTree
from addie.calculate_gr.gofrview import GofRView
from addie.calculate_gr.sofqview import SofQView

from addie.icons import icons_rc

DEBUG = False

IPYTHON_STARTUP_CODE = '''import numpy as np
from mantid.simpleapi import *
'''


class MainWindow(QMainWindow):
    """ Main addie window
    """

    first_oncat_authentication = True
    oncat = None # object to use to retrieve IPTS numbers...etc. Created by oncat_authentication_handler.py

    # config.json ======================================================
    # those infos will be automatically retrieve from the config.json file
    facility = ''
    instrument = {"full_name": "",   # Powgen, Nomad ...
                  "short_name": ""}  # PG3, NOM ...
    list_instrument = {"full_name": [],
                       "short_name": []}
    config_calibration_folder = {"pre": "", "post": ""}
    config_characterization_folder = {"pre": "", "post": ""}

    calibration_extension = ""
    characterization_extension = ""

    cache_folder = './' # defined in the advanced window
    output_folder = './' # defined in the advanced window

    placzek_default = {}

    # list of arguments to use in Import from ONCat and to display for filters
    oncat_metadata_filters = []
    # end of config.json ======================================================

    # Master json created by master_table_loader_from_database where keys are "1-10,15,16" with list of json and
    # list of titles (used to fix conflicts when loading)
    # json_to_import = {'1,2,5-10': {'list_of_json': [json1, json2, json5, json6, json7, ... json10],
    #                                'title': "title_1_1,2,5-10'},
    #                   '20-30': {'list_of_json': [...',
    #                             'title': "title_20-30"},
    #                   ... }
    json_to_import = None

    # flag that will clear or not the master table before loading data
    clear_master_table_before_loading = True

    # load los.csv options
    ascii_loader_option = None   # None, 1, 2, 3, 4
    ascii_loader_dictionary = {}

    # intermediate and output grouping files
    grouping_dict = {'filename': "",
                     'nbr_groups': "N/A",
                     'enabled': False}
    intermediate_grouping = copy.deepcopy(grouping_dict)
    output_grouping = copy.deepcopy(grouping_dict)

    statusbar_display_time = 5000  # 5s

    # external ui (use to make sure there is only one open at a time
    import_from_database_ui = None
    import_from_database_ui_position = None

    import_from_run_number_ui = None
    import_from_run_number_ui_position = None

    oncat_authentication_ui_position = None

    conflicts_solver_ui_position = None

    advanced_window_ui = None
    make_calibration_ui = None
    make_calibration_ui_position = None
    table_tree_ui = None
    table_tree_ui_position = None
    placzek_ui = None
    reduction_configuration_ui = None
    reduction_configuration_ui_position = None

    material_ui = None
    material_ui_position = None

    mass_density_ui = None
    mass_density_ui_position = None

    geometry_ui_position = None

    # config file to initialize the widgets (example Q and R range in PDF tab)
    current_path = os.path.dirname(os.path.dirname(__file__))
    addie_config_file = os.path.join(os.path.dirname(addie.__file__),  "config.json")

    # master table reduction configuration
    reduction_configuration = {}

    # configuration of master table
    config_dict = OrderedDict()
    reset_config_dict = OrderedDict()
    active_config_name = ''
    list_config_displayed = []

    # will list the various ui for each row using a random number as key
    dict_widget = {'ui': None,
                   'status': False}
    master_table_right_click_buttons = {'activate': copy.deepcopy(dict_widget),
                                        'activate_check_all': copy.deepcopy(dict_widget),
                                        'activate_uncheck_all': copy.deepcopy(dict_widget),
                                        'activate_inverse': copy.deepcopy(dict_widget),
                                        'cells': copy.deepcopy(dict_widget),
                                        'cells_paste': copy.deepcopy(dict_widget),
                                        'cells_copy': copy.deepcopy(dict_widget),
                                        'cells_clear': copy.deepcopy(dict_widget),
                                        'rows_paste': copy.deepcopy(dict_widget),
                                        'rows_copy': copy.deepcopy(dict_widget),
                                        'rows_duplicate': copy.deepcopy(dict_widget),
                                        'rows_remove': copy.deepcopy(dict_widget),
                                        'reset': copy.deepcopy(dict_widget),
                                        'clear': copy.deepcopy(dict_widget),
                                        'import_from_config_append': copy.deepcopy(dict_widget),
                                        'import_from_file_append': copy.deepcopy(dict_widget),
                                        'import_from_database_append': copy.deepcopy(dict_widget),
                                        'export': copy.deepcopy(dict_widget),
                                        'plot': copy.deepcopy(dict_widget),
                                        }

    placzek_info_dict = {'order_text': None,
                         'order_index': None,
                         'is_self': None,
                         'is_interference': None,
                         'fit_spectrum_text': None,
                         'fit_spectrum_index': None,
                         'lambda_fit_min': None,
                         'lambda_fit_max': None,
                         'lambda_fit_delta': None,
                         'lambda_calc_min': None,
                         'lambda_calc_max': None,
                         'lambda_calc_delta': None,
                         }

    master_table_list_ui = OrderedDict()
    master_table_cells_copy = {'temp': [],
                               'list_column': [],
                               'row': [],
                               }

    table_headers = {'h1': [],
                     'h2': [],
                     'h3': [],
                     }

    table_width = {'h1': [],
                   'h2': [],
                   'h3': []}

    # to find which h1 column goes with wich h2 and which h3
    table_columns_links = {'h1': [],
                           'h2': [],
                           'h3': [],
                           }
    tree_dict = None
    tree_ui = None
    minimum_col_width = 10

    # headers from master table
    h1_header_table = None
    h2_header_table = None
    h3_header_table = None

    undo_table = {}
    max_undo_list = 10
    undo_index = max_undo_list
    undo_button_enabled = False
    redo_button_enabled = False

    debugging = False
    load_intermediate_step_ok = False
    remove_dynamic_temperature_flag = False
    current_folder = os.getcwd()
    configuration_folder = current_folder
    calibration_folder = ''
    characterization_folder = ''
    file_path = os.getcwd()
    table_selection_buffer = {}
    _run_thread_sum_scans = RunThread()
    advanced_window_idl_groupbox_visible = False

    logbook_thread = LogbookThread()
    number_of_last_log_files_to_display = 10
    previous_list_of_log_files = []

    _run_thread = RunThread()
    job_monitor_thread = JobMonitorThread()
    _mantid_thread_array = list(itertools.repeat(MantidThread(), 30))
    config_section_name = 'Configuration'
    job_monitor_interface = None
    logbook_interface = None
    job_list = []

    init_height_main_gui = 1058
    previous_splitter_height = -1
    first_time_resizing_blocked = True

    o_help_autonom = None
    o_help_ndabs = None
    o_help_scans = None
    o_help_mantid = None

    def __init__(self, parent=None, processing_mode):
        """ Initialization
        Parameters
        ----------
        """
        QMainWindow.__init__(self, parent)

        # if self.debugging:
        #     self.calibration_folder = '/SNS/NOM/IPTS-17118/shared/'
        #     self.characterization_folder = '/SNS/NOM/shared/CALIBRATION/'

        # Initialize the UI widgets
        self.ui = load_ui('mainWindow.ui', baseinstance=self)
        self._promote_widgets()

        self.ui.graphicsView_sq.set_main(self)

	# Set the post-processing mode
	self.post_processing = processing_mode  # mantid or 'idl'

        # set widgets
        self.init_parameters()
        self.set_default_folders_path()
        self._init_widgets()
        InitStep1(parent=self)
        InitStep2(parent=self)
        self.init_master_table()

        # define the event handling methods
        #self.ui.mantid_run_reduction.clicked.connect(self.do_mantid_run_reduction)

        # bragg diffraction tab
        self.ui.pushButton_loadBraggFile.clicked.connect(self.do_load_bragg_file)
        self.ui.checkBox_bank1.toggled.connect(self.evt_plot_bragg_bank)
        self.ui.checkBox_bank2.toggled.connect(self.evt_plot_bragg_bank)
        self.ui.checkBox_bank3.toggled.connect(self.evt_plot_bragg_bank)
        self.ui.checkBox_bank4.toggled.connect(self.evt_plot_bragg_bank)
        self.ui.checkBox_bank5.toggled.connect(self.evt_plot_bragg_bank)
        self.ui.checkBox_bank6.toggled.connect(self.evt_plot_bragg_bank)
        self.ui.comboBox_xUnit.currentIndexChanged.connect(self.evt_switch_bragg_unit)
        self.ui.radioButton_multiBank.toggled.connect(self.evt_change_gss_mode)

        self.ui.pushButton_rescaleGSAS.clicked.connect(self.do_rescale_bragg)

        self.ui.pushButton_gsasColorStyle.clicked.connect(self.do_set_bragg_color_marker)
        self.ui.pushButton_clearBraggCanvas.clicked.connect(self.do_clear_bragg_canvas)

        # for tab G(R)
        self.ui.pushButton_loadSQ.clicked.connect(self.do_load_sq)
        self.ui.comboBox_SofQType.currentIndexChanged.connect(self.evt_change_sq_type)
        self.ui.pushButton_clearSofQ.clicked.connect(self.do_clear_sq)
        self.ui.pushButton_showQMinMax.clicked.connect(self.do_show_sq_bound)
        self.ui.pushButton_generateGR.clicked.connect(self.do_generate_gr)
        self.ui.pushButton_loadGofR.clicked.connect(self.do_load_gr)
        self.ui.pushButton_saveGR.clicked.connect(self.do_save_gr)
        self.ui.pushButton_clearGrCanvas.clicked.connect(self.do_clear_gr)
        self.ui.pushButton_saveSQ.clicked.connect(self.do_save_sq)
        self.ui.pushButton_editSofQ.clicked.connect(self.do_edit_sq)
        self.ui.pushButton_generateSQ.clicked.connect(self.do_generate_sq)

        self.ui.doubleSpinBoxQmin.valueChanged.connect(self.evt_qmin_changed)
        self.ui.doubleSpinBoxQmax.valueChanged.connect(self.evt_qmax_changed)

        self.ui.pushButton_rescaleSq.clicked.connect(self.do_rescale_sofq)
        self.ui.pushButton_rescaleGr.clicked.connect(self.do_rescale_gofr)

        self.ui.pushButton_grColorStyle.clicked.connect(self.do_set_gofr_color_marker)
        self.ui.pushButton_sqColorStyle.clicked.connect(self.do_set_sq_color_marker)

        #  menu operations
        self.ui.actionReset_GofR_tab.triggered.connect(self.do_reset_gr_tab)
        self.ui.actionReset_GSAS_tab.triggered.connect(self.do_reset_gsas_tab)
        self.ui.actionQuit.triggered.connect(self.evt_quit)
        self.ui.actionCheat_sheet.triggered.connect(self.do_show_help)

        # organize widgets group
        self._braggBankWidgets = {1: self.ui.checkBox_bank1,
                                  2: self.ui.checkBox_bank2,
                                  3: self.ui.checkBox_bank3,
                                  4: self.ui.checkBox_bank4,
                                  5: self.ui.checkBox_bank5,
                                  6: self.ui.checkBox_bank6}
        self._braggBankWidgetRecords = dict()
        for bank_id in self._braggBankWidgets:
            checked = self._braggBankWidgets[bank_id].isChecked()
            self._braggBankWidgetRecords[bank_id] = checked

        # define the driver
        self._myController = driver.AddieDriver()

        # class variable for easy access
        self._gssGroupName = None
        self._currDataDir = None
        self._inFixedDirectoryStructure = False
        self._currWorkDir = os.getcwd()

        # some controlling variables
        self._currBraggXUnit = str(self.ui.comboBox_xUnit.currentText())
        if self._currBraggXUnit == 'Q':
            self._currBraggXUnit = 'MomentumTransfer'
        self._onCanvasGSSBankList = list()

        # mutex-like variables
        self._noEventBankWidgets = False

        # help (refer to DGSPlanner and HFIR Powder reduction GUI)
        self._assistantProcess = QProcess(self)

        # a collection of sub window
        self._editSqDialog = None
        self._editedSofQDict = dict()

        # color management
        self._pdfColorManager = PDFPlotManager()

        self.save_raw_config()

        if DEBUG:
            o_row = TableRowHandler(parent=self)
            for _row in np.arange(10):
                o_row.insert_row(row=_row)

        self.ucams = get_ucams()

    def save_raw_config(self):
        '''this will allow the user to reset the full table and get it back in its initial state'''
        o_current_table_config = TableConfig(parent=self)
        current_config = o_current_table_config.get_current_config()

        inside_dict = OrderedDict()
        inside_dict['table'] = current_config
        inside_dict['active'] = False

        self.reset_config_dict = inside_dict

    def init_parameters(self):
        ConfigurationInitializer(parent=self)

    def set_default_folders_path(self):
        '''Where the calibration_folder and characterization folder will be initialized
        using instrument name...

        this is very important when the instrument changed
        '''
        instrument_short_name = self.instrument["short_name"]
        config_calibration_folder = self.config_calibration_folder

        self.calibration_folder = os.path.join(config_calibration_folder["pre"],
                                               instrument_short_name,
                                               config_calibration_folder["post"])

        config_characterization_file = self.config_characterization_folder
        self.characterization_folder = os.path.join(config_characterization_file["pre"],
                                                    instrument_short_name,
                                                    config_characterization_file["post"])

    def init_master_table(self):
        o_table = TableInitialization(parent=self)
        o_table.init_master_table()
        o_table.init_signals()

    def _promote_widgets(self):
        # frame_graphicsView_bragg
        graphicsView_layout = QVBoxLayout()
        self.ui.frame_graphicsView_bragg.setLayout(graphicsView_layout)
        self.ui.graphicsView_bragg = BraggView(self)
        graphicsView_layout.addWidget(self.ui.graphicsView_bragg)

        # frame_graphicsView_sq
        graphicsView_layout = QVBoxLayout()
        self.ui.frame_graphicsView_sq.setLayout(graphicsView_layout)
        self.ui.graphicsView_sq= SofQView(self)
        graphicsView_layout.addWidget(self.ui.graphicsView_sq)

        # frame_graphicsView_gr
        graphicsView_layout = QVBoxLayout()
        self.ui.frame_graphicsView_gr.setLayout(graphicsView_layout)
        self.ui.graphicsView_gr = GofRView(self)
        graphicsView_layout.addWidget(self.ui.graphicsView_gr)

        # frame_treeWidget_grWsList
        temp_layout = QVBoxLayout()
        self.ui.frame_treeWidget_grWsList.setLayout(temp_layout)
        self.ui.treeWidget_grWsList = GofRTree(self)
        temp_layout.addWidget(self.ui.treeWidget_grWsList)

        # frame_treeWidget_braggWSList
        temp_layout = QVBoxLayout()
        self.ui.frame_treeWidget_braggWSList.setLayout(temp_layout)
        self.ui.treeWidget_braggWSList = BraggTree(self)
        temp_layout.addWidget(self.ui.treeWidget_braggWSList)

        # frame_dockWidget_ipython
        temp_layout = QVBoxLayout()
        self.ui.frame_dockWidget_ipython.setLayout(temp_layout)
        self.ui.dockWidget_ipython = InProcessJupyterConsole(self, startup_code=IPYTHON_STARTUP_CODE)
        temp_layout.addWidget(self.ui.dockWidget_ipython)

    def _init_widgets(self):
        """ Initialize widgets
        Returns
        -------
        """

        #init_size_splitter = self.ui.splitter.size()
        #self.init_size_splitter_height = init_size_splitter.height()
        #init_width = self.size()
        #self.init_width = init_width.width()

        self.ui.splitter.setStyleSheet("""
            QSplitter::handle {
               image: url(':/MPL Toolbar/splitter_icon.png');
            }
            """)

        self.ui.splitter_2.setStyleSheet("""
        	QSplitter::handle {
        	   image: url(':/MPL Toolbar/vertical_splitter_icon.png');
        	}
        	""")
        self.ui.splitter_2.setSizes([1000,1])

        self.ui.splitter_3.setStyleSheet("""
                    QSplitter::handle {
                       image: url(':/MPL Toolbar/splitter_icon.png');
                    }
                    """)

        self.ui.splitter_4.setStyleSheet("""
                    QSplitter::handle {
                       image: url(':/MPL Toolbar/splitter_icon.png');
                    }
                    """)

        self.ui.splitter_5.setStyleSheet("""
                    QSplitter::handle {
                       image: url(':/MPL Toolbar/vertical_splitter_icon.png');
                    }
                    """)

        self.ui.label_25.setPixmap(QtGui.QPixmap(":/MPL Toolbar/search_icon.png"))
        self.ui.search_logo_label.setPixmap(QtGui.QPixmap(":/MPL Toolbar/search_icon.png"))
        self.ui.clear_name_search_2.setIcon(QtGui.QIcon(":/MPL Toolbar/clear_icon.png"))
        self.ui.clear_search_button.setIcon(QtGui.QIcon(":/MPL Toolbar/clear_icon.png"))

        self.ui.settings_table_button.setIcon(QtGui.QIcon(":/MPL Toolbar/settings_icon.png"))

        self.ui.comboBox_xUnit.clear()
        self.ui.comboBox_xUnit.addItems(['TOF', 'dSpacing', 'Q'])
        index = self.ui.comboBox_xUnit.findText('dSpacing', Qt.MatchFixedString)
        self.ui.comboBox_xUnit.setCurrentIndex(index)

        self.ui.treeWidget_braggWSList.set_main_window(self)
        self.ui.treeWidget_braggWSList.add_main_item('workspaces', append=True, as_current_index=False)

        self.ui.treeWidget_grWsList.set_main_window(self)
        self.ui.treeWidget_grWsList.add_main_item('workspaces', append=True, as_current_index=False)
        self.ui.treeWidget_grWsList.add_main_item('SofQ', append=True, as_current_index=False)

        self.ui.comboBox_SofQType.clear()
        self.ui.comboBox_SofQType.addItem('S(Q)')
        self.ui.comboBox_SofQType.addItem('S(Q)-1')
        self.ui.comboBox_SofQType.addItem('Q[S(Q)-1]')
        self.ui.comboBox_SofQType.setCurrentIndex(0)

        self.ui.radioButton_multiBank.setChecked(True)

        # add the combo box for PDF type
        self.ui.comboBox_pdfType.addItems(['G(r)', 'g(r)', 'RDF(r)'])

        # some starting value
        self.ui.doubleSpinBoxDelR.setValue(0.01)

        # set a constant item to combobox Sq
        self.ui.comboBox_SofQ.addItem('All')

        # PDF filter
        self.ui.comboBox_pdfCorrection.clear()
        self.ui.comboBox_pdfCorrection.addItem('No Modification')
        self.ui.comboBox_pdfCorrection.addItem('Lorch')

        # set the tab to 0
        self.ui.main_tab.setCurrentIndex(0)

        # set the lower limit on Qmin
        self.ui.doubleSpinBoxQmin.setDecimals(6)
        self.ui.doubleSpinBoxQmin.setMinimum(1.E-10)

        self.activate_reduction_tabs()

    @property
    def controller(self):
        """
        get handler of controller
        :return:
        """
        return self._myController

    def do_set_bragg_color_marker(self):
        """
        set the color/marker to plots on bragg canvas
        :return:
        """
        # get the current figure' on-shown plots
        plot_id_label_list = self.ui.graphicsView_bragg.get_current_plots()

        # get the line ID, color, and marker
        plot_id_list, color, marker = ps.get_plots_color_marker(self, plot_label_list=plot_id_label_list)
        if plot_id_list is None:
            # operation is cancelled by user
            pass
        else:
            # set the color and mark
            for plot_id in plot_id_list:
                self.ui.graphicsView_bragg.updateLine(ikey=plot_id, linecolor=color, marker=marker,
                                                      markercolor=color)

        return

    def do_set_gofr_color_marker(self):
        """
        set the color/marker to plots on G(r) canvas
        :return:
        """
        # get the line ID, color, and marker
        plot_id_label_list = self.ui.graphicsView_gr.get_current_plots()

        # get the line ID, color, and marker
        plot_id_list, color, marker = ps.get_plots_color_marker(self, plot_label_list=plot_id_label_list)
        if plot_id_list is None:
            # operation is cancelled by user
            pass
        else:
            # set the color and mark
            for plot_id in plot_id_list:
                self.ui.graphicsView_gr.updateLine(ikey=plot_id, linecolor=color, marker=marker,
                                                   markercolor=color)

        return

    def do_set_sq_color_marker(self):
        """
        set the color/marker on S(q) canvas
        Returns:

        """
        # get the line ID, color, and marker
        plot_id_label_list = self.ui.graphicsView_sq.get_current_plots()

        # get the line ID, color, and marker
        plot_id_list, color, marker = ps.get_plots_color_marker(self, plot_label_list=plot_id_label_list)
        if plot_id_list is None:
            # operation is cancelled by user
            pass
        else:
            # set the color and mark
            for plot_id in plot_id_list:
                self.ui.graphicsView_sq.updateLine(ikey=plot_id, linecolor=color, marker=marker,
                                                   markercolor=color)

        return

    def do_show_help(self):
        """ Show help
        Copied from DGSPlanner
        """
        # close previous service
        self._assistantProcess.close()
        self._assistantProcess.waitForFinished()

        # launch
        # helper_url = QUrl('addie_helper.html')
        helper_url = QUrl('https://neutrons.github.io/addie/index.html')
        QDesktopServices.openUrl(helper_url)

        return

    def do_clear_bragg_canvas(self):
        """
        Clear all the plots on Bragg-canvas
        Returns
        -------

        """
        self.ui.graphicsView_bragg.reset()
        self.clear_bank_checkboxes()
        self._onCanvasGSSBankList = list()

        return

    def do_clear_gr(self):
        """
        Clear G(r) canvas
        Returns
        -------

        """
        self.ui.graphicsView_gr.reset()

        return

    def do_clear_sq(self):
        """
        Remove all lines from S(Q) canvas
        Returns
        -------

        """
        self.ui.graphicsView_sq.reset()

        return

    def do_generate_gr(self):
        """ Handling event from push button 'Generate G(r)' by generating G(r) of selected workspaces
        :return:
        """
        # get S(Q) workspace
        selected_sq = str(self.ui.comboBox_SofQ.currentText())
        if selected_sq == 'All':
            sq_ws_name_list = list()
            for index in range(self.ui.comboBox_SofQ.count()):
                item = str(self.ui.comboBox_SofQ.itemText(index))
                if item != 'All':
                    # add S(Q) name unless it is 'All'
                    sq_ws_name_list.append(item)
                # END-IF
            # END-FOR
        else:
            # selected S(Q) is a single S(Q) name
            sq_ws_name_list = [selected_sq]

        # generate G(r)
        self.generate_gr(sq_ws_name_list=sq_ws_name_list)

        return

    def generate_gr(self, sq_ws_name_list):
        """Generate G(r) from specified S(Q) workspaces
        :param sq_ws_name_list:
        :return:
        """
        # check inputs
        assert isinstance(sq_ws_name_list, list), 'S(Q) workspaces {0} must be given by list but not {1}.' \
                                                  ''.format(sq_ws_name_list, type(sq_ws_name_list))
        if len(sq_ws_name_list) == 0:
            raise RuntimeError('User specified an empty list of S(Q)')

        # get r-range and q-range
        min_r = float(self.ui.doubleSpinBoxRmin.value())
        max_r = float(self.ui.doubleSpinBoxRmax.value())
        delta_r = float(self.ui.doubleSpinBoxDelR.value())

        min_q = float(self.ui.doubleSpinBoxQmin.value())
        max_q = float(self.ui.doubleSpinBoxQmax.value())

        use_filter_str = str(self.ui.comboBox_pdfCorrection.currentText())
        if use_filter_str == 'No Modification':
            pdf_filter = None
        elif use_filter_str == 'Lorch':
            pdf_filter = 'lorch'
        else:
            raise RuntimeError('PDF filter {0} is not recognized.'.format(use_filter_str))
        rho0_str = str(self.ui.lineEdit_rho.text())
        try:
            rho0=float(rho0_str)
        except ValueError:
            rho0 = None

        # PDF type
        pdf_type = str(self.ui.comboBox_pdfType.currentText())

        # loop for all selected S(Q)
        for sq_ws_name in sq_ws_name_list:
            # calculate G(r)
            gr_ws_name = self._myController.calculate_gr(sq_ws_name, pdf_type, min_r, delta_r, max_r,
                                                         min_q, max_q, pdf_filter, rho0)

            # check whether G(r) is on GofR plot or not in order to determine this is an update or new plot
            update = self.ui.graphicsView_gr.has_gr(gr_ws_name)

            # plot G(R)
            if not update:
                # a new line
                gr_color, gr_style, gr_marker, gr_alpha = self._pdfColorManager.add_gofr(sq_ws_name, gr_ws_name, max_q)
                gr_label = '{0} Q: ({1}, {2})'.format(sq_ws_name, min_q, max_q)
                self.plot_gr(gr_ws_name, gr_color, gr_style, gr_marker, gr_alpha, gr_label)
            else:
                self.plot_gr(gr_ws_name, gr_line_color=None, gr_line_style=None, gr_line_marker=None,
                             gr_line_alpha=None, gr_line_label=None)

            # add to tree
            # TODO/ISSUE/NOW - Need to find out the name of the
            gr_param_str = 'G(r) for Q(%.3f, %.3f)' % (min_q, max_q)
            self.ui.treeWidget_grWsList.add_gr(gr_param_str, gr_ws_name)
        # END-FOR

        return

    def do_rescale_bragg(self):
        """ Rescale the figure of Bragg diffraction data
        :return:
        """
        min_y_value = self.ui.graphicsView_bragg.get_y_min()
        max_y_value = self.ui.graphicsView_bragg.get_y_max()
        delta_y = max(1, max_y_value - min_y_value)

        y_lower_limit = min_y_value - delta_y * 0.05
        y_upper_limit = max_y_value + delta_y * 0.05

        self.ui.graphicsView_bragg.setXYLimit(ymin=y_lower_limit, ymax=y_upper_limit)

        return

    def do_rescale_sofq(self):
        """ Rescale the figure of S(Q)
        :return:
        """
        min_y_value = self.ui.graphicsView_sq.get_y_min()
        max_y_value = self.ui.graphicsView_sq.get_y_max()
        delta_y = max(1, max_y_value - min_y_value)

        y_lower_limit = min_y_value - delta_y * 0.05
        y_upper_limit = max_y_value + delta_y * 0.05

        self.ui.graphicsView_sq.setXYLimit(ymin=y_lower_limit, ymax=y_upper_limit)

        return

    def do_rescale_gofr(self):
        """ Rescale the figure of G(r)
        :return:
        """
        min_y_value = self.ui.graphicsView_gr.get_y_min()
        max_y_value = self.ui.graphicsView_gr.get_y_max()
        delta_y = max(1, max_y_value - min_y_value)

        y_lower_limit = min_y_value - delta_y * 0.05
        y_upper_limit = max_y_value + delta_y * 0.05

        self.ui.graphicsView_gr.setXYLimit(ymin=y_lower_limit, ymax=y_upper_limit)

        return

    def do_reset_gr_tab(self):
        """
        Reset G(r)-tab, including deleting all the G(r) and S(Q) workspaces,
        clearing the G(r) and S(Q) trees, and clearing both G(r) and S(Q) canvas
        Returns:
        None
        """
        # get workspace from trees
        workspace_list = self.ui.treeWidget_grWsList.get_workspaces()

        # reset the tree to initial status
        self.ui.treeWidget_grWsList.reset_gr_tree()

        # delete all the workspaces
        for workspace in workspace_list:
            self._myController.delete_workspace(workspace)

        # clear all the canvas
        self.ui.graphicsView_gr.clear_all_lines()
        self.ui.graphicsView_sq.clear_all_lines()

        # clear the S(Q) combo box
        self.ui.comboBox_SofQ.clear()
        self.ui.comboBox_SofQ.addItem('All')

        return

    def do_reset_gsas_tab(self):
        """
        Reset the GSAS-tab including
        1. deleting all the GSAS workspaces
        2. clearing the GSAS tree
        3. clearing GSAS canvas
        Returns:
        None
        """
        # delete all workspaces: get GSAS workspaces from tree
        gsas_group_node_list = self.ui.treeWidget_braggWSList.get_main_nodes(output_str=False)
        for gsas_group_node in gsas_group_node_list:
            # skip if the workspace is 'workspaces'
            gss_node_name = str(gsas_group_node.text())
            if gss_node_name == 'workspaces':
                continue
            # get the split workspaces' names and delete
            gsas_ws_name_list = self.ui.treeWidget_braggWSList.get_child_nodes(gsas_group_node, output_str=True)
            for workspace in gsas_ws_name_list:
                self._myController.delete_workspace(workspace)
            # END-FOR

            # guess for the main workspace and delete
            gss_main_ws = gss_node_name.split('_group')[0]
            self._myController.delete_workspace(gss_main_ws, no_throw=True)

        # END-FOR (gsas_group_node)

        # reset the GSAS tree
        self.ui.treeWidget_braggWSList.reset_bragg_tree()

        # clear checkboxes for banks
        self.clear_bank_checkboxes()

        # clear the canvas
        self.ui.graphicsView_bragg.reset()

        return

    def clear_bank_checkboxes(self):
        self._noEventBankWidgets = True
        for check_box in list(self._braggBankWidgets.values()):
            check_box.setChecked(False)
        self._noEventBankWidgets = False

        return

    def plot_bragg(self, bragg_ws_list,  clear_canvas=False):
        """
        Parameters
        ----------
        bragg_ws_list: list of (single spectrum) Bragg workspace
        clear_canvas

        Returns
        -------

        """
        # check
        assert isinstance(bragg_ws_list, list)

        # clear canvas if necessary
        if clear_canvas:
            self.ui.graphicsView_bragg.reset()

        # get unit
        curr_unit = self._currBraggXUnit
        # curr_unit = str(self.ui.comboBox_xUnit.currentText())
        # if curr_unit == 'Q':
        #     curr_unit =

        # plot all workspsaces
        for bragg_ws_name in bragg_ws_list:
            # get the last section of the workspace name: _bank%d
            postfix = bragg_ws_name.split('_')[-1]

            if postfix.startswith('bank') and 0 <= int(postfix.split('bank')[1]) <= 6:
                # belonged to a Bragg-workspace-group
                ws_group = bragg_ws_name.split('_%s' % postfix)[0] + '_group'
                bank_id = int(bragg_ws_name.split('bank')[1])
                vec_x, vec_y, vec_e = self._myController.get_bragg_data(ws_group_name=ws_group, bank_id=bank_id,
                                                                        x_unit=curr_unit)

                # construct dictionary for plotting
                plot_data_dict = dict()
                plot_data_dict[ws_group] = dict()
                plot_data_dict[ws_group][bank_id] = (vec_x, vec_y, vec_e)

                # set the bank to be checked
                self._braggBankWidgets[bank_id].setChecked(True)

                # plot
                self.ui.graphicsView_bragg.plot_banks(plot_data_dict, curr_unit)

            else:
                # plot arbitrary data
                # print '[DB] Switch to multi-GSAS mode.  Re-plot {0}'.format(bragg_ws_name)
                vec_x, vec_y, vec_e = self._myController.get_ws_data(bragg_ws_name)
                self.ui.graphicsView_bragg.plot_general_ws(bragg_ws_name, vec_x, vec_y, vec_e)

        return

    def plot_gr(self, gr_ws_name, gr_line_color, gr_line_style, gr_line_marker, gr_line_alpha, gr_line_label,
                auto=False):
        """Plot G(r) by their names (workspace as protocol)
        :param gr_ws_name:
        :param gr_line_color:
        :param gr_line_style:
        :param gr_line_marker:
        :param gr_line_alpha:
        :param gr_line_label:
        :param auto:
        :return:
        """
        # get the value
        vec_r, vec_g, vec_ge = self._myController.get_ws_data(gr_ws_name)

        # check whether the workspace is on the figure
        print('[DB...BAT] G(r) graphic has plot {0} is {1}. Keys are {2}' \
              ''.format(gr_ws_name, self.ui.graphicsView_gr.has_gr(gr_ws_name),
                        self.ui.graphicsView_gr.get_current_grs()))

        if self.ui.graphicsView_gr.has_gr(gr_ws_name):
            # update G(r) value of an existing plot
            self.ui.graphicsView_gr.update_gr(gr_ws_name, vec_r, vec_g, vec_ge)
        else:
            # a new g(r) plot
            if auto:
                gr_line_color, gr_line_style, gr_line_alpha = self._pdfColorManager.get_gr_line(gr_ws_name)

            # check
            assert isinstance(gr_line_color, str), 'G(r) line color {0} must be a string but not {1}.' \
                                                   ''.format(gr_line_color, type(gr_line_color))
            assert isinstance(gr_line_style, str), 'G(r) line style {0} must be given by str but not {1}.' \
                                                   ''.format(gr_line_style, type(gr_line_style))
            assert isinstance(gr_line_alpha, float), 'G(r) line alpha {0} must be given by float but not {1}.' \
                ''.format(gr_line_alpha, type(gr_line_alpha))
            assert isinstance(gr_line_marker, str) or gr_line_marker is None,\
                'G(r) line marker {0} must be given by str or None but not {1}.' \
                ''.format(gr_line_marker, type(gr_line_marker))
            assert isinstance(gr_line_label, str), 'G(r) line label {0} must be given by list but not {1}.' \
                                                   ''.format(gr_line_label, type(gr_line_label))

            # plot G(R)
            self.ui.graphicsView_gr.plot_gr(gr_ws_name, vec_r, vec_g, vec_ge, False,
                                            gr_line_color, gr_line_style, gr_line_marker, gr_line_alpha, gr_line_label)
        # END-FOR

        return

    def plot_sq(self, sq_ws_name, sq_color, clear_prev):
        """
        Plot S(Q)
        :param sq_ws_name:
        :param sq_color: color of S(Q).  If None, then try to find it from PDF color manager
        :param clear_prev:
        :return:
        """
        # clear previous lines
        if clear_prev:
            self.ui.graphicsView_sq.reset()

        # get data
        vec_q, vec_sq, vec_se = self._myController.get_sq(sq_ws_name)

        # get the unit & do conversion if necessary
        sq_type = str(self.ui.comboBox_SofQType.currentText())
        if sq_type == 'S(Q)':
            # use the original S(Q)
            sq_unit = 'S(Q)'
            vec_y = vec_sq
        elif sq_type == 'S(Q)-1':
            # use S(Q)-1
            sq_unit = 'S(Q)-1'
            vec_y = vec_sq - 1
        elif sq_type == 'Q[S(Q)-1]':
            # use Q(S(Q)-1)
            sq_unit = 'Q[S(Q)-1]'
            vec_y = vec_q * (vec_sq - 1)
        else:
            raise RuntimeError('None of S(Q), S(Q)-1 or Q(S(Q)-1) is chosen.')

        # plot
        if clear_prev:
            reset = True
        else:
            reset = False

        # get color
        if sq_color is None:
            sq_color = self._pdfColorManager.add_sofq(sq_ws_name)

        self.ui.graphicsView_sq.plot_sq(sq_ws_name, vec_q, vec_y, vec_se, sq_unit, reset,
                                        color=sq_color)

        return

    def do_load_bragg_file(self):
        """
        Load Bragg files including GSAS, NeXus, 3-column ASCii.
        Returns
        -------
        """
        # get file
        ext = 'GSAS (*.gsa *.gda *.gss);;Processed Nexus (*.nxs);;dat (*.dat);;All (*.*)'

        # get default dir
        if self._currDataDir is None:
            default_dir = os.getcwd()
        else:
            default_dir = self.getDefaultDir(sub_dir='GSAS')

        bragg_file_names = QFileDialog.getOpenFileNames(self, 'Choose Bragg File', default_dir, ext)
        if isinstance(bragg_file_names, tuple):
            bragg_file_names = bragg_file_names[0]
        if bragg_file_names is None or bragg_file_names == '' or len(bragg_file_names) == 0:
            return
        bragg_file_names = [str(bragg_file_name) for bragg_file_name in bragg_file_names]

        # update stored data directory
        try:
            self._currDataDir = os.path.split(os.path.abspath(bragg_file_names[0]))[0]
        except IndexError as index_err:
            err_msg = 'Unable to get absolute path of {0} due to {1}'.format(bragg_file_names, index_err)
        self.check_in_fixed_dir_structure(sub_dir='GSAS')

        # load file
        try:
            gss_ws_names = list()
            for bragg_file_name in bragg_file_names:
                gss_ws_name = self._myController.load_bragg_file(bragg_file_name)
                gss_ws_names.append(gss_ws_name)
                # split
                # FIXME - _gssGroupName may have an issie with multiple-GSS mode
                gssGroupName, banks_list, bank_angles = self._myController.split_to_single_bank(gss_ws_name)

                # add to tree
                self.ui.treeWidget_braggWSList.add_bragg_ws_group(gssGroupName, banks_list)

            # get plot mode
            if len(bragg_file_names) == 1:
                self.ui.graphicsView_bragg.set_to_single_gss(True)
                self.ui.radioButton_multiBank.setChecked(True)
                self.ui.radioButton_multiGSS.setChecked(False)
            else:
                self.ui.graphicsView_bragg.set_to_single_gss(False)
                self.ui.radioButton_multiBank.setChecked(False)
                self.ui.radioButton_multiGSS.setChecked(True)

            multi_bank_mode = self.ui.radioButton_multiBank.isChecked()

            if multi_bank_mode:
                # single-GSS/multi-bank mode
                # rename bank
                for bank_id in self._braggBankWidgets:
                    bank_check_box = self._braggBankWidgets[bank_id]

                    if bank_id > len(bank_angles) or bank_angles[bank_id - 1] is None:
                        bank_check_box.setText('Bank %d' % bank_id)
                    else:
                        bank_check_box.setText('Bank %.1f' % bank_angles[bank_id - 1])
                        # END-IF
                    # END-IF-ELSE
                # END-FOR

                # clear all previous lines
                self.ui.graphicsView_bragg.reset()
            # END-IF

            # banks
            self._onCanvasGSSBankList = self.get_bragg_banks_selected()
            if len(self._onCanvasGSSBankList) == 0:
                # select bank 1 as default
                self._noEventBankWidgets = True
                self.ui.checkBox_bank1.setChecked(True)
                self._noEventBankWidgets = False
                self._onCanvasGSSBankList = self.get_bragg_banks_selected()

            # while in multiple-gss mode, no change will be made on the canvas at all

            # prepare to plot new Bragg
            # change unit
            ws_data_dict = dict()
            plot_data_dict = dict()
            for gss_ws_name in gss_ws_names:
                gss_group_name = gss_ws_name + '_group'
                for bank_id in self._onCanvasGSSBankList:
                    vec_x, vec_y, vec_e = self._myController.get_bragg_data(gss_group_name, bank_id, self._currBraggXUnit)
                    ws_data_dict[bank_id] = (vec_x, vec_y, vec_e)
                plot_data_dict[gss_group_name] = ws_data_dict

            # plot
            # FIXME/ISSUE/NOW - get a summary on calling to plot_banks
            self.ui.graphicsView_bragg.plot_banks(plot_data_dict, self._currBraggXUnit)

            # reset unit
            self.reset_bragg_data_range(self._currBraggXUnit)

        except:

            self.setStyleSheet("QStatusBar{padding-left:8px;color:red;font-weight:bold;}")
            self.ui.statusbar.showMessage("Error loading {}".format(bragg_file_names), 10000)

    def do_load_gr(self):
        """
        Load an ASCII file containing G(r)
        Returns:
        """
        # get default dir
        if self._currDataDir is None:
            default_dir = os.getcwd()
        else:
            default_dir = self.getDefaultDir('gofr')

        # pop out file
        file_filter = 'Data Files (*.dat);; PDFgui (*.gr);;All Files (*.*)'
        g_file_name = QFileDialog.getOpenFileName(self, 'Open a G(r) file', default_dir, file_filter)
        if isinstance(g_file_name, tuple):
            g_file_name = g_file_name[0]
        # return if operation is cancelled
        if g_file_name is None or g_file_name == '':
            return

        # update current data directory
        self._currDataDir = os.path.split(os.path.abspath(g_file_name))[0]
        # set default data directory if in fixed file structure
        self.check_in_fixed_dir_structure('gofr')

        # read file
        status, ret_obj = self._myController.load_gr(g_file_name)
        if not status:
            err_msg = ret_obj
            print('[Error]: %s' % err_msg)
            return
        else:
            gr_ws_name = ret_obj

        # plot
        gr_color, gr_style, gr_marker, gr_alpha = self._pdfColorManager.add_gofr(None, gr_ws_name, None)
        gr_label = gr_ws_name

        self.plot_gr(gr_ws_name, gr_color, gr_style, gr_marker, gr_alpha, gr_label)

        # put the loaded G(r) workspace to tree 'workspaces'
        self.ui.treeWidget_grWsList.add_child_main_item('workspaces', gr_ws_name)

        return

    def check_in_fixed_dir_structure(self, sub_dir):
        """
        Check whether _currDataDir ends with 'GSAS', 'gofr' or 'SofQ'
        If it is, then reset the _currDataDir to its upper directory and set the in-format flag;
        Otherwise, keep as is
        """
        # make sure that the last character of currDataDir is not /
        if self._currDataDir.endswith('/') or self._currDataDir.endswith('\\'):
            # consider Linux and Windows case
            self._currDataDir = self._currDataDir[:-1]

        # split
        main_path, last_dir = os.path.split(self._currDataDir)
        if last_dir == sub_dir:
            self._inFixedDirectoryStructure = True
            self._currDataDir = main_path
        else:
            self._inFixedDirectoryStructure = False
        # END-IF-ELSE

        return

    def getDefaultDir(self, sub_dir):
        """ Get the default data directory.
        If is in Fixed-Directory-Structure, then _currDataDir is the parent directory for all GSAS, gofr and SofQ
        and thus return the data directory with _currDataDir joined with sub_dir
        Otherwise, no operation

        :param sub_dir:
        :return: directory
        """
        # check
        assert isinstance(sub_dir, str), 'sub directory must be a string but not %s.' % type(sub_dir)

        if self._inFixedDirectoryStructure:
            default_dir = os.path.join(self._currDataDir, sub_dir)
        else:
            default_dir = self._currDataDir

        return default_dir

    @staticmethod
    def get_file_names_from_dialog(default_dir, file_filter, caption):
        """
        get the file name from a dialog
        :param default_dir:
        :param file_filter:
        :param caption
        :return:
        """
        # TODO/TEST/NOW - Find out what this method can get!!!
        # check input
        assert isinstance(default_dir, str), 'Default directory {0} must be a string but not a {1}.' \
                                             ''.format(default_dir, type(default_dir))
        assert isinstance(file_filter, str), 'File filter {0} must be a string but not a {1}.' \
            ''.format(file_filter, type(file_filter))

        # generate a dialog to get the file name to save G(r)
        export_dialog = QFileDialog()
        export_dialog.setWindowTitle(caption)
        export_dialog.setDirectory(default_dir)
        export_dialog.setAcceptMode(QFileDialog.AcceptSave)
        export_dialog.setNameFilter(file_filter)

        # quit if it is not accepted
        if export_dialog.exec_() != QFileDialog.Accepted:
            return None
        elif len(export_dialog.selectedFiles()) == 0:
            return None

        # get the file name from dialog
        file_name_list = list()
        for file_name in export_dialog.selectedFiles():
            file_name_list.append(str(file_name))

        return file_name_list

    def do_load_sq(self):
        """
        Load S(Q) from file
        Returns
        -------

        """
        # get default dir
        if self._currDataDir is None:
            default_dir = os.getcwd()
        else:
            default_dir = self.getDefaultDir(sub_dir='SofQ')

        # get the file
        ext = 'nxs (*.nxs);;dat (*.dat);;All (*.*)'
        sq_file_names = QFileDialog.getOpenFileNames(self, 'Choose S(Q) File', default_dir, ext)
        if isinstance(sq_file_names, tuple):
            sq_file_names = sq_file_names[0]
        if sq_file_names is None or sq_file_names == '' or len(sq_file_names) == 0:
            return

        # update current data directory
        self._currDataDir = os.path.split(os.path.abspath(sq_file_names[0]))[0]
        self.check_in_fixed_dir_structure('SofQ')

        # load S(q)
        for sq_file_name in sq_file_names:
            sq_file_name = str(sq_file_name)
            sq_ws_name, q_min, q_max = self._myController.load_sq(sq_file_name)
            # add to color management
            sq_color = self._pdfColorManager.add_sofq(sq_ws_name)

            # set to the tree and combo box
            self.ui.treeWidget_grWsList.add_sq(sq_ws_name)
            self.ui.comboBox_SofQ.addItem(sq_ws_name)
            self.ui.comboBox_SofQ.setCurrentIndex(self.ui.comboBox_SofQ.count()-1)

            # set the UI widgets
            self.ui.doubleSpinBoxQmin.setValue(q_min)
            self.ui.doubleSpinBoxQmax.setValue(q_max)

            # plot S(Q)
            sq_name = self._myController.get_current_sq_name()

            self.plot_sq(sq_name, sq_color=sq_color, clear_prev=False)

            # calculate and calculate G(R)
            self.do_generate_gr()

        return

    def do_edit_sq(self):
        """
        Launch a dialog box to edit S(Q) by shift and scaling.
        :return:
        """
        # create dialog instance if it does not exist
        if self._editSqDialog is None:
            self._editSqDialog = addie.calculate_gr.edit_sq_dialog.EditSofQDialog(self)

        # get current S(Q) list and add to dialog
        sq_name_list = list()
        num_sq = self.ui.comboBox_SofQ.count()
        for isq in range(num_sq):
            sq_name = str(self.ui.comboBox_SofQ.itemText(isq))
            sq_name_list.append(sq_name)
        # END-FOR

        self._editSqDialog.add_sq_by_name(sq_name_list)

        # show
        self._editSqDialog.show()

        return

    def do_generate_sq(self):
        """
        generate S(Q) from G(r) by PDFFourierTransform
        :return:
        """
        # TODO/ISSUE/NOW - Need to implement!
        raise NotImplementedError('Dialog box for generating S(Q) has not been implemented yet.')
        # get setup
        min_r = float(self.ui.doubleSpinBoxRmin.value())
        max_r = float(self.ui.doubleSpinBoxRmax.value())
        min_q = self.ui.doubleSpinBoxQmin.value()
        max_q = self.ui.doubleSpinBoxQmax.value()

        # launch the dialog box
        if self._generateSofQDialog is None:
            self._generateSofQDialog = blabla

        self._generateSofQDialog.set_r_range(min_r, max_r)
        self._generateSofQDialog.set_q_range(min_q, max_q)

        self._generateSofQDialog.show()

        return

    def signal_generate_sq(self, arg_dict):
        """
        signal handling method to generate S(q)
        Note:  https://github.com/neutrons/FastGR/issues/91
        :return:
        """
        # check input
        assert isinstance(arg_dict, dict), 'Input arguments {0} must be given in a dictionary but not a {1}.' \
                                           ''.format(arg_dict, type(arg_dict))

        # determine the selected G(r)
        gr_ws_name_list = self.ui.treeWidget_grWsList.get_workspaces()
        # print '[DB] Selected G(r) workspaces have {0} items.'.format(len(gr_ws_name_list))
        # for gr in gr_ws_name_list:
        #     print '[DB] G(r) {0} of type {1}.'.format(gr, type(gr))

        # check the arguments
        for required_param in ['Qmin', 'Qmax', 'Rmin', 'Rmax', 'DeltaR']:
            if required_param not in list(arg_dict.keys()):
                raise RuntimeError('Not sufficient parameter (missing {0}) to generate S(Q) from G(r).'
                                   ''.format(required_param))

        # TODO/FIXME/FUTURE - Call Mantid algorithm to calculate S(Q)
        raise NotImplementedError('Implement this in future.')

        return

    def do_save_gr(self):
        """
        Save the selected the G(r) from menu to ASCII file
        :return:
        """
        # TEST/ISSUE/NOW - Look at https://github.com/neutrons/FastGR/issues/28

        # read the selected item from the tree
        gr_name_list = self.ui.treeWidget_grWsList.get_selected_items_of_level(2, excluded_parent='SofQ',
                                                                               return_item_text=True)
        if len(gr_name_list) != 1:
            err_msg = 'Error! Only 1 workspace of G(r) that can be selected.  So far %d is selected.' \
                'They are %s.' % (len(gr_name_list), str(gr_name_list))
            QMessageBox.warning(self, 'Error', err_msg)
            return
        else:
            gr_ws_name = gr_name_list[0]

        # pop-up a dialog for the file to save
        default_dir = os.getcwd()
        caption = 'Save G(r)'

        # TEST/ISSUE/NOW - Refactor the following part out to be a standard widget
        file_filter_str = 'XYE (*.xye);;CSV XYE (*.csv);;PDFgui (*.gr);;RMCProfile (*.dat)'
        gr_file_name = self.get_file_names_from_dialog(default_dir, file_filter_str, caption)[0]

        # check the file extension and use the file extension to determine G(r) file type
        file_name, file_ext = os.path.splitext(gr_file_name)
        if file_ext.lower().startswith('.xye'):
            gr_file_type = 'xye'
        elif file_ext.lower().startswith('.csv'):
            gr_file_type = 'csv'
        elif file_ext.lower().startswith('.gr'):
            gr_file_type = 'gr'
        elif file_ext.lower().startswith('.dat'):
            gr_file_type = 'rmcprofile'
        else:
            # unsupported
            raise RuntimeError('G(r) file with extension {0} is not supported.'.format(file_ext))

        # save!
        self._myController.save_ascii(gr_ws_name, gr_file_name, gr_file_type)

        return

    def do_save_sq(self):
        """Save the selected the G(r) from menu to ASCII file
        :return:
        """
        # TEST/ISSUE/NOW - Test!

        # read the selected item from the tree... return if nothing is selected
        sq_name_list = self.ui.treeWidget_grWsList.get_selected_items_of_level(2, excluded_parent='GofR',
                                                                               return_item_text=True)
        if len(sq_name_list) == 0:
            return

        # loop the SofQ name to save
        file_filter = 'XYE (*.xye);;CSV XYE (*.csv);;SofQ (*.sq)'

        for sq_name in sq_name_list:
            # get the output file name first
            out_file_name = QFileDialog.getSaveFileName(self,
                                                        'Input File Name to Save S(Q) {0}'.format(sq_name),
                                                        self._currWorkDir, file_filter)
            if isinstance(out_file_name, tuple):
                out_file_name = out_file_name[0]
            if out_file_name is None or len(out_file_name) == 0:
                # skip if the user cancel the operation on this S(Q)
                continue

            # get the directory, file name and extension
            self._currWorkDir = os.path.dirname(out_file_name)
            file_name, file_ext = os.path.splitext(out_file_name)
            if file_ext.lower().startswith('.xye'):
                sq_file_type = 'xye'
            elif file_ext.lower().startswith('.csv'):
                sq_file_type = 'csv'
            elif file_ext.lower().startswith('.sq'):
                sq_file_type = 'dat'
            elif file_ext.lower().startswith('.dat'):
                sq_file_type = 'dat'
            elif len(file_ext.strip()) == 0:
                raise RuntimeError('There is no extension of file {0}. Unable to determine file type.'
                                   ''.format(out_file_name))
            else:
                raise RuntimeError('File type {0} cannot be recognized.'.format(file_ext))

            # save file
            self._myController.save_ascii(sq_name, out_file_name, sq_file_type)
        # END-FOR

        return

    def do_show_sq_bound(self):
        """
        Show or hide the left and right boundary of the S(Q)
        :return:
        """
        q_left = self.ui.doubleSpinBoxQmin.value()
        q_right = self.ui.doubleSpinBoxQmax.value()
        self.ui.graphicsView_sq.toggle_boundary(q_left, q_right)

        return

    def get_bragg_banks_selected(self):
        """
        Find out the banks of bragg-tab that are selected.
        Returns:

        """
        bank_id_list = list()
        for bank_id in self._braggBankWidgets:
            # access the checkbox
            bank_checkbox = self._braggBankWidgets[bank_id]
            # append
            if bank_checkbox.isChecked():
                bank_id_list.append(bank_id)
        # END-FOR

        return bank_id_list

    def edit_sq(self, sq_name, scale_factor, shift):
        """Edit S(Q) in workspace with scale_factor * Y[i] + shift
        :param sq_name:
        :param scale_factor:
        :param shift:
        :return:
        """
        # convert
        sq_name = str(sq_name)

        # check inputs
        assert isinstance(sq_name, str), 'S(Q) workspace name {0} must be a string but not a {1}.' \
                                         ''.format(sq_name, type(sq_name))
        assert isinstance(scale_factor, float), 'Scale factor {0} must be a float but not a {1}.' \
                                                ''.format(scale_factor, type(scale_factor))
        assert isinstance(shift, float), 'Shift {0} must be a float but not a {1}.'.format(shift, type(shift))

        # call the controller
        edit_sq_name = sq_name + '_Edit'
        self._myController.edit_matrix_workspace(sq_name, scale_factor, shift, edit_sq_name)
        # add new S(Q)
        self._pdfColorManager.add_sofq(edit_sq_name)

        color, marker = self.ui.graphicsView_sq.get_plot_info(sq_name)
        print('[DB...BAT] Original SofQ {0} has color {0} marker {1}'.format(color, marker))

        # re-plot
        vec_q, vec_s, vec_e = self._myController.get_sq(edit_sq_name)
        self.ui.graphicsView_sq.plot_sq(edit_sq_name, vec_q, vec_s, vec_e, sq_y_label=sq_name + ' In Edit',
                                        reset_color_mark=False,
                                        color=color, marker=marker)

        # calculate G(r) too
        self.generate_gr([edit_sq_name])

        return

    def evt_change_gss_mode(self):
        """ switch between multi-gss/single-bank mode and singl-gss/multiple-bank mode
        :return:
        """
        # check the mode (multiple bank or multiple GSS)
        single_gss_mode = self.ui.radioButton_multiBank.isChecked()
        assert single_gss_mode != self.ui.radioButton_multiGSS.isChecked(),\
            'Multi bank and multi GSS cannot be checked simultaneously.'

        # get the banks that are selected
        to_plot_bank_list = self.get_bragg_banks_selected()
        on_canvas_ws_list = self.ui.graphicsView_bragg.get_workspaces()
        # return with doing anything if the canvas is empty, i.e., no bank is selected
        if len(to_plot_bank_list) == 0:
            return
        # return if there is no workspace that is plotted on canvas now
        if len(on_canvas_ws_list) == 0:
            return

        # set to single GSS
        self.ui.graphicsView_bragg.set_to_single_gss(single_gss_mode)

        # process the plot with various situation
        if single_gss_mode:
            # switch to single GSAS mode from multiple GSAS mode.
            #  select the arbitrary gsas file to
            assert len(to_plot_bank_list) == 1, 'From multi-GSS-single-Bank mode, only 1 bank can be selected.'

            # skip if there is one and only one workspace
            if len(on_canvas_ws_list) == 1:
                return
            else:
                status, ws_name_list = self.ui.treeWidget_braggWSList.get_current_main_nodes()
                if not status:
                    raise RuntimeError(str(ws_name_list))
                else:
                    plot_ws_name = ws_name_list[0]

            # plot
            plot_ws_name = plot_ws_name.split('_group')[0]
            bragg_bank_ws = '%s_bank%d' % (plot_ws_name, to_plot_bank_list[0])
            self.plot_bragg(bragg_ws_list=[bragg_bank_ws], clear_canvas=True)

        else:
            # multiple GSAS mode. as currently there is one GSAS file that is plot, then the first bank
            # that is plotted will be kept on the canvas
            # assumption: switched from single-bank mode

            # skip if there is one and only 1 bank that is selected
            # if len(to_plot_bank_list) == 1:
            # TEST/ISSUE/NOW - Need to re-plot with correct color!
            #     return
            # else:
            # choose first bank
            bank_on_canvas = to_plot_bank_list[0]

            # disable all the banks except the one to plot. Notice the mutex must be on
            self._noEventBankWidgets = True
            for bank_id in self._braggBankWidgets:
                if bank_id != bank_on_canvas:
                    self._braggBankWidgets[bank_id].setChecked(False)
            self._noEventBankWidgets = False

            # plot
            plot_ws_name = on_canvas_ws_list[0]
            bragg_bank_ws = '%s_bank%d' % (plot_ws_name, bank_on_canvas)
            self.plot_bragg(bragg_ws_list=[bragg_bank_ws], clear_canvas=True)

            # set
            self._onCanvasGSSBankList = [bank_on_canvas]

        # END-IF-ELSE

        return

    def evt_plot_bragg_bank(self):
        """
        Find out which bank will be plot

        cases to trigger this event:
        1. select more banks
        2. deselect some banks

        Returns
        -------

        """
        # check mutex for not responding the event
        if self._noEventBankWidgets:
            return
        # check
        #assert self._gssGroupName is not None, 'GSAS group name cannot be None'

        # get mode for plotting
        plot_multi_gss = self.ui.radioButton_multiGSS.isChecked()

        # find the change of the banks
        current_bank_set = set(self.get_bragg_banks_selected())
        prev_bank_set = set(self._onCanvasGSSBankList)

        if plot_multi_gss:
            # multi-gss/single-bank mode
            # get the banks to remove
            rm_bank_list = self._onCanvasGSSBankList[:]

            # deselect all the old banks and thus turn on the mutex
            self._noEventBankWidgets = True
            # turn off the
            self.set_bragg_banks_selected(self._onCanvasGSSBankList, False)
            # turn off mutex
            self._noEventBankWidgets = False

            # set banks to add
            new_bank_list = list(current_bank_set - prev_bank_set)
            assert len(new_bank_list) <= 1, 'Impossible to have more than 1 banks selected in multi-GSS mode.'

            # set the current on canvas
            self._onCanvasGSSBankList = new_bank_list

            # print '[DB...BAT] Multi-GSS-Mode: New ... ', new_bank_list, '; Remove... ', rm_bank_list

        else:
            # single-gss/multi-bank mode
            # determine the banks to add
            new_bank_list = list(current_bank_set - prev_bank_set)
            rm_bank_list = list(prev_bank_set - current_bank_set)

            # print '[DB...BAT] Single-GSS-Mode: New ... ', new_bank_list, '; Remove... ', rm_bank_list

            # set the current on-canvas
            self._onCanvasGSSBankList = list(current_bank_set)

        # END-IF-ELSE

        # get GSS data (group)
        if plot_multi_gss:
            # multiple GSAS file/single bank mode: get GSAS group from tree
            gss_group_list = self.ui.treeWidget_braggWSList.get_main_nodes()
            gss_group_list.remove('workspaces')

        else:
            # single GSAS file mode
            status, ret_obj = self.ui.treeWidget_braggWSList.get_current_main_nodes()
            if status:
                gss_group = ret_obj[0]
            else:
                raise RuntimeError('Unable to get current selected main node(s) due to {0}.'.format(ret_obj))
            gss_group_list = [gss_group]

        # remove banks from plot
        for gss_group_name in gss_group_list:
            self.ui.graphicsView_bragg.remove_gss_banks(gss_group_name, rm_bank_list)

        # get new bank data
        plot_data_dict = dict()
        for ws_group in gss_group_list:
            ws_data_dict = dict()
            for bank_id in new_bank_list:
                vec_x, vec_y, vec_e = self._myController.get_bragg_data(ws_group, bank_id, self._currBraggXUnit)
                ws_data_dict[bank_id] = (vec_x, vec_y, vec_e)
            # END-FOR
            plot_data_dict[ws_group] = ws_data_dict
        # END-FOR

        if plot_multi_gss:
            self.ui.graphicsView_bragg.set_to_single_gss(False)
        else:
            self.ui.graphicsView_bragg.set_to_single_gss(True)
            status, ws_name_list = self.ui.treeWidget_braggWSList.get_current_main_nodes()
            plot_data_dict = {ws_name_list[0]: plot_data_dict[ws_name_list[0]]}

        # plot new
        self.ui.graphicsView_bragg.plot_banks(plot_data_dict, self._currBraggXUnit)

        # reset
        self.reset_bragg_data_range(self._currBraggXUnit)

        # rescale
        self.do_rescale_bragg()

        return

    def evt_switch_bragg_unit(self):
        """
        Unit of Bragg plot is changed.
        Requirements:
        1. clear the canvas
        2. plot all the banks in the new units
        3. reset the limit
        Returns
        -------

        """
        # get current unit and check whether re-plot all banks is not a choice
        x_unit = str(self.ui.comboBox_xUnit.currentText())
        # convert Q to MomentumTransfer by Mantid standard
        if x_unit == 'Q':
            x_unit = 'MomentumTransfer'

        if x_unit == self._currBraggXUnit:
            # return if no change. then this cannot happen
            raise RuntimeError('New unit %s is same as original unit %s.' % (x_unit, self._currBraggXUnit))
        else:
            self._currBraggXUnit = x_unit

        # reset canvas
        self.ui.graphicsView_bragg.reset()

        # get bank to plot
        bank_list = self.get_bragg_banks_selected()

        # get data sets
        #  = self.ui.treeWidget_braggWSList.get_main_nodes()
        ws_group_list = self.ui.treeWidget_braggWSList.get_selected_items_of_level(
            target_item_level=1, excluded_parent=None, return_item_text=True)
        if 'workspace' in ws_group_list:
            ws_group_list.remove('workspaces')
        assert len(ws_group_list) > 0, 'At least 1 GSS file must be selected.'

        # check
        assert len(bank_list) == 1 or len(ws_group_list) == 1, 'Must be either single bank (%d now) or ' \
            'single GSS (%d now).' % (len(bank_list),
                                      len(ws_group_list))

        # get data and plot
        plot_data_dict = dict()
        for ws_group in ws_group_list:
            ws_data_dict = dict()
            for bank_id in bank_list:
                vec_x, vec_y, vec_e = self._myController.get_bragg_data(ws_group, bank_id, self._currBraggXUnit)
                ws_data_dict[bank_id] = (vec_x, vec_y, vec_e)
            # END-FOR
            plot_data_dict[ws_group] = ws_data_dict
        # END-FOR

        # plot
        self.ui.graphicsView_bragg.plot_banks(plot_data_dict, self._currBraggXUnit)

        # reset unit
        self.reset_bragg_data_range(x_unit)

        return

    def reset_bragg_data_range(self, x_unit):
        """

        Parameters
        ----------
        x_unit

        Returns
        -------

        """
        self.ui.graphicsView_bragg.set_unit(x_unit)

        if x_unit == 'TOF':
            self.ui.graphicsView_bragg.setXYLimit(xmin=0, xmax=20000, ymin=None, ymax=None)
        elif x_unit == 'MomentumTransfer':
            self.ui.graphicsView_bragg.setXYLimit(xmin=0, xmax=20, ymin=None, ymax=None)
        elif x_unit == 'dSpacing':
            self.ui.graphicsView_bragg.setXYLimit(xmin=0, xmax=7, ymin=None, ymax=None)
        else:
            raise RuntimeError('Unit %s unknown' % x_unit)

        return

    def evt_change_sq_type(self):
        """ Event handling to plot S(Q)
        Returns
        -------

        """
        # get the current S(Q) names
        curr_sq_list = self.ui.graphicsView_sq.get_shown_sq_names()
        if len(curr_sq_list) == 0:
            return

        # reset the canvas
        self.ui.graphicsView_sq.reset()

        # re-plot
        for sq_name in curr_sq_list:
            # plot S(Q)
            self.plot_sq(sq_name, sq_color=None, clear_prev=False)

        return

    def evt_qmax_changed(self):
        """
        Handle if the user change the value of Qmax of S(Q) including
        1. moving the right boundary in S(q) figure
        Returns:

        """
        q_min = self.ui.doubleSpinBoxQmin.value()
        q_max = self.ui.doubleSpinBoxQmax.value()

        if q_min < q_max and self.ui.graphicsView_sq.is_boundary_shown():
            self.ui.graphicsView_sq.move_right_indicator(q_max, relative=False)

        return

    def evt_qmin_changed(self):
        """

        Returns:

        """
        q_min = self.ui.doubleSpinBoxQmin.value()
        q_max = self.ui.doubleSpinBoxQmax.value()

        if q_min < q_max and self.ui.graphicsView_sq.is_boundary_shown():
            self.ui.graphicsView_sq.move_left_indicator(q_min, relative=False)

        return

    def evt_quit(self):
        """
        Quit the application
        Returns:

        """
        self.close()

    def get_default_data_dir(self):
        """
        Get default data directory
        Returns:
        """
        return self._currDataDir

    def get_workflow(self):
        """
        Return the reference to the main workflow controller
        Returns: workflow controller

        """
        return self._myController

    def process_workspace_change(self, new_ws_list):
        """
        Process (including
        1. add workspace name to tree list and etc) when detecting that
        there is some change to any workspace

        Parameters
        ----------
        new_ws_list :: list of new workspaces' names

        Returns
        -------

        """
        # check input
        assert isinstance(new_ws_list, list), 'Input workspace list must be a list of string' \
            'but not %s.' % str(type(new_ws_list))

        # print 'current tab = ', self.ui.tabWidget_2.currentIndex(), self.ui.tabWidget_2.currentWidget(),
        # print self.ui.tabWidget_2.currentWidget().objectName()
        # print 'current workspaces: ', self._myController.get_current_workspaces()

        # add to tree
        if len(new_ws_list) > 0:
            if self.ui.tabWidget_2.currentWidget().objectName() == 'tab_gR':
                # a new G(r) or S(q)
                for new_ws in new_ws_list:
                    ws_unit = self._myController.get_ws_unit(new_ws)
                    if ws_unit != 'MomentumTransfer':
                        is_gr = True
                    else:
                        # case for SofQ
                        is_gr = False
                        # add to combo box
                        self.ui.comboBox_SofQ.addItem(new_ws)
                        self.ui.treeWidget_grWsList.add_sq(new_ws)
                        # plot generated S(Q)
                        self.plot_sq(sq_ws_name=new_ws, sq_color=None, clear_prev=False)
                    # END-IF
                    self.ui.treeWidget_grWsList.add_arb_gr(new_ws, is_gr)

            elif self.ui.tabWidget_2.currentWidget().objectName() == 'tab_bragg':
                # new Bragg pattern
                for new_ws in new_ws_list:
                    self.ui.treeWidget_braggWSList.add_arb_gr(new_ws)
            # END-IF-ELSE

        return

    def remove_gr_from_plot(self, gr_name):
        """Remove a GofR line from GofR canvas
        :param gr_name: supposed to the G(r) name that is same as workspace name and plot key on canvas as well
        :return:
        """
        # check
        assert isinstance(gr_name, str), 'G(r) plot key {0} must be a string but not a {1}' \
                                         ''.format(gr_name, type(gr_name))

        # remove
        self.ui.graphicsView_gr.remove_gr(plot_key=gr_name)

        return

    def remove_gss_from_plot(self, gss_group_name, gss_bank_ws_name_list):
        """Remove a GSAS group from canvas if they exits
        :param gss_group_name: name of the GSS node, i.e., GSS workspace group's name
        :param gss_bank_ws_name_list: list of names of GSS single banks' workspace name
        :return:
        """
        # check
        assert isinstance(gss_group_name, str), 'GSS group workspace name must be a string but not %s.' \
            '' % str(type(gss_group_name))
        assert isinstance(gss_bank_ws_name_list, list), 'GSAS-single-bank workspace names {0} must be given by ' \
                                                        'list but not {1}.'.format(gss_bank_ws_name_list,
                                                                                   type(gss_bank_ws_name_list))
        if len(gss_bank_ws_name_list) == 0:
            raise RuntimeError('GSAS-single-bank workspace name list is empty!')

        # get bank IDs
        bank_ids = list()
        for gss_bank_ws in gss_bank_ws_name_list:
            bank_id = int(gss_bank_ws.split('_bank')[-1])
            bank_ids.append(bank_id)

        # remove
        self.ui.graphicsView_bragg.remove_gss_banks(gss_group_name, bank_ids)

        # check if there is no such bank's plot on figure, make sure the checkbox is unselected
        # turn on the mutex lock
        self._noEventBankWidgets = True

        for bank_id in range(1, 7):
            has_plot_on_canvas = len(self.ui.graphicsView_bragg.get_ws_name_on_canvas(bank_id)) > 0
            self._braggBankWidgets[bank_id].setChecked(has_plot_on_canvas)

        # turn off the mutex lock
        self._noEventBankWidgets = False

        return

    def remove_sq_from_plot(self, sq_name):
        """
        Remove an SofQ line from SofQ canvas
        Args:
            sq_name: supposed to be the S(Q) name which is same as workspace name and plot key of canvas

        Returns:

        """
        # check
        assert isinstance(sq_name, str)

        # remove
        if self.ui.graphicsView_sq.is_on_canvas(sq_name):
            self.ui.graphicsView_sq.remove_sq(sq_ws_name=sq_name)

        return

    def set_bragg_banks_selected(self, bank_id_list, status):
        """
        set the status of selected bank IDs
        Note: mutex on Bragg Bank selection widgets is not turned on!!!
        Parameters
        ----------
        bank_id_list
        status

        Returns
        -------

        """
        # check inputs
        assert isinstance(bank_id_list, list), 'Bank IDs {0} must be given in a list but not a {1}.' \
                                               ''.format(bank_id_list, type(bank_id_list))
        assert isinstance(status, bool), 'Selection status {0} must be a boolean but not a {1}.' \
                                         ''.format(status, type(status))

        # set
        for bank_id in bank_id_list:
            self._braggBankWidgets[bank_id].setChecked(status)

        return

    def set_bragg_ws_to_plot(self, gss_group_name):
        """
        Set a Bragg workspace group to plot.  If the Bragg-tab is in
        (1) single-GSS mode, then switch to plot this gss_group
        (2) multiple-GSS mode, then add this group to current canvas
        Parameters
        ----------
        gss_group_name

        Returns
        -------

        """
        # check
        assert isinstance(gss_group_name, str), 'GSS workspace group name is expected to be a string, but not' \
            ' %s.' % str(type(gss_group_name))

        # rule out the unsupported situation
        assert gss_group_name.endswith('_group'), 'GSAS workspace group\' name must be ends with _group, ' \
            'but not as %s.' % gss_group_name
        root_ws_name = gss_group_name.split('_group')[0]

        # process
        if self.ui.radioButton_multiBank.isChecked():
            # single-GSS/multi-bank mode
            # reset canvas
            self.ui.graphicsView_bragg.reset()

            # get the banks to plot
            selected_banks = self.get_bragg_banks_selected()

            bragg_ws_list = ['%s_bank%d' % (root_ws_name, bank_id) for bank_id in selected_banks]
            self.plot_bragg(bragg_ws_list=bragg_ws_list, clear_canvas=False)

        else:
            # multiple-GSS/single-bank mode
            # canvas is not be reset

            # get the bank to plot
            selected_banks = self.get_bragg_banks_selected()
            assert len(selected_banks) <= 1, 'At most 1 bank can be plot in multiple-GSS mode.'

            # form the workspace
            bragg_ws = '%s_bank%d' % (root_ws_name, selected_banks[0])

            self.plot_bragg(bragg_ws_list=[bragg_ws], clear_canvas=False)

        # END-IF-ELSE

        return

    def set_ipython_script(self, script):
        """
        Write a command (python script) to ipython console
        Parameters
        ----------
        script

        Returns
        -------

        """
        # check
        assert isinstance(script, str)

        #
        if len(script) == 0:
            # ignore
            return
        else:
            # write to the console
            self.ui.dockWidget_ipython.execute(script)

        return

    def update_sq_boundary(self, boundary_index, new_position):
        """Update the S(Q) range at the main app inputs
        :param boundary_index:
        :param new_position:
        :return:
        """
        # check
        assert isinstance(boundary_index, int), 'Boundary index {0} must be an integer but not {1}.' \
                                                ''.format(boundary_index, type(boundary_index))
        assert isinstance(new_position, float), 'New position {0} must be a float but not {1}.' \
                                                ''.format(new_position, type(new_position))

        # set value
        if boundary_index == 1:
            # left boundary
            self.ui.doubleSpinBoxQmin.setValue(new_position)
        elif boundary_index == 2:
            # right boundary
            self.ui.doubleSpinBoxQmax.setValue(new_position)
        else:
            # exception
            raise RuntimeError('Boundary index %f in method update_sq_boundary() is not '
                               'supported.' % new_position)

        return

    def add_edited_sofq(self, sofq_name, edited_sq_name, shift_value, scale_factor_value):
        """add an edited S(Q) to cached dictionary
        :param sofq_name:
        :param edited_sq_name:
        :param shift_value:
        :param scale_factor_value:
        :return:
        """
        # check
        assert isinstance(sofq_name, str), 'SofQ workspace name {0} must be a string but not a {1}.' \
                                           ''.format(sofq_name, type(sofq_name))
        assert isinstance(edited_sq_name, str), 'Edited S(Q) workspace name {0} must be a string but not a {1}.' \
                                                ''.format(edited_sq_name, type(edited_sq_name))

        # add the entry for the original S(Q) if not done yet
        if sofq_name not in self._editedSofQDict:
            self._editedSofQDict[sofq_name] = dict()

        # add entry
        self._editedSofQDict[sofq_name][shift_value, scale_factor_value] = edited_sq_name

        # add the line and color manager
        self._pdfColorManager.add_sofq(edited_sq_name)

        return

    def has_edit_sofq(self, raw_sofq_name, shift_value, scale_factor_value):
        """ check whether an edited S(Q) has been cached already
        :param raw_sofq_name:
        :param shift_value:
        :param scale_factor_value:
        :return:
        """
        # check
        assert isinstance(raw_sofq_name, str)

        if raw_sofq_name not in self._editedSofQDict:
            return False

        return (shift_value, scale_factor_value) in self._editedSofQDict[raw_sofq_name]

    # menu
    def action_preview_ascii_clicked(self):
        o_gui = Step3GuiHandler(parent=self)
        o_gui.browse_file()

    def action_load_configuration_clicked(self):
        o_import_config = ImportConfiguration(parent=self)
        o_import_config.run()

    def action_save_configuration_clicked(self):
        o_export_config = ExportConfiguration(parent=self)
        o_export_config.run()

    def action_undo_clicked(self):
        o_undo = UndoHandler(parent=self)
        o_undo.undo_table()

    def action_redo_clicked(self):
        o_undo = UndoHandler(parent=self)
        o_undo.redo_table()

    def help_about_clicked(self):
        _about = AboutDialog(parent=self)
        _about.display()

    def advanced_option_clicked(self):
        AdvancedWindowLauncher(parent = self)

    def activate_reduction_tabs(self):
        if self.post_processing == 'idl':
            tab_0 = True
            tab_1 = True
            tab_2 = False
            current_index=0
            visible_menu_configuration = True
        else:
            tab_0 = False
            tab_1 = False
            tab_2 = True
            current_index=2
            visible_menu_configuration = False
        self.ui.main_tab.setTabEnabled(0, tab_0)
        self.ui.main_tab.setTabEnabled(1, tab_1)
        self.ui.main_tab.setTabEnabled(2, tab_2)
        self.setStyleSheet("QTabBar::tab::disabled {width: 0; height: 0; margin: 0; padding: 0; border: none;} ")
        self.ui.main_tab.setCurrentIndex(current_index)

        # also hide the file>configration buttons when working with Mantid
        self.ui.menuLoad_Configuration.menuAction().setVisible(visible_menu_configuration)

    def menu_ipts_file_transfer_clicked(self):
        _o_ipts = IptsFileTransferDialog(parent=self)
        _o_ipts.show()

    def main_tab_widget_changed(self, tab_selected):
        if tab_selected == 0:
            o_gui = Step1GuiHandler(parent=self)
            self.check_step1_gui()
        if tab_selected == 1:
            _o_gui = Step2GuiHandler(parent=self)
            _o_gui.check_gui()

    def window_job_monitor_clicked(self):
        job_handler = JobStatusHandler(parent=self)

    def help_button_clicked(self, button_name='autonom'):
        help_button_activator(parent=self, button_name=button_name)

    # job utility
    def launch_job_manager(self, job_name='', script_to_run=None, thread_index=-1):
        job_handler = JobStatusHandler(parent=self, job_name=job_name,
                                       script_to_run=script_to_run,
                                       thread_index=thread_index)
        job_handler.start()

    def kill_job(self, row=-1):
        job_row = self.job_list[row]
        parent = psutil.Process(job_row['pid'])
        for child in parent.children(recursive=True):
            child.kill()
#	    child.wait()
        parent.kill()

        table_widget = self.job_monitor_interface.ui.tableWidget
        table_widget.removeCellWidget(row, 2)
        _item = QTableWidgetItem('Killed')
        table_widget.setItem(row, 2, _item)
        job_row['status'] = "killed"
        job_row['pid'] = None
        self.job_list[row] = job_row

    def start_refresh_text_thread(self):
        _run_thread = self.logbook_thread
        _run_thread.setup(parent=self)
        _run_thread.update_text.connect(self.update_logbook)
        _run_thread.start()

    def update_logbook(self, text):
        if self.job_monitor_interface is None:
            self.logbook_thread.stop()
        else:
            _logbook_handler = LogbookHandler(parent=self)

    # tab1
    def select_current_folder_clicked(self):
        o_gui = Step1GuiHandler(parent=self)
        o_gui.select_working_folder()
        self.check_step1_gui()

    def diamond_edited(self):
        self.check_step1_gui()

    def diamond_background_edited(self):
        self.check_step1_gui()

    def vanadium_edited(self):
        self.check_step1_gui()

    def vanadium_background_edited(self):
        self.check_step1_gui()

    def sample_background_edited(self):
        self.check_step1_gui()

    def create_new_autonom_folder_button_clicked(self, status):
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.new_autonom_group_box(status=status)

    def output_folder_radio_buttons(self):
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.manual_output_folder_button_handler()
        o_gui_handler.check_go_button()

    def manual_output_folder_field_edited(self):
        self.check_step1_gui()

    def manual_output_folder_button_clicked(self):
        o_gui = Step1GuiHandler(parent=self)
        o_gui.select_manual_output_folder()
        self.check_step1_gui()

    def check_step1_gui(self):
        '''check the status of the step1 GUI in order to enable or not the GO BUTTON at the bottom'''
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.check_go_button()

    def run_autonom(self):
        """Will first create the output folder, then create the exp.ini file"""
        _run_autonom = RunStep1(parent=self)
        _run_autonom.create_folder()
        print(os.getcwd())
        _run_autonom.create_exp_ini_file()

    def help_button_clicked_autonom(self):
        self.help_button_clicked(button_name='autonom')

    def create_exp_ini_clicked(self):
        _run_autonom = RunStep1(parent=self, run_autonom=False)
        _run_autonom.create_folder()
        _run_autonom.create_exp_ini_file()

    # tab2
    def resize_table_post_processing_tab(self, height, width):
        pass

    def move_to_folder_clicked(self):
        o_load_table = loadTableIntermediateStepInterface(parent=self)
        o_load_table.show()

    def move_to_folder_step2(self):
        if not self.load_intermediate_step_ok:
            return

        o_gui = Step2GuiHandler(parent=self)
        o_gui.move_to_folder()
        self.populate_table_clicked()

    def populate_table_clicked(self):

        self.ui.table.blockSignals(True)

        _pop_table = PopulateMasterTable(parent=self)
        _pop_table.run()
        _error_reported = _pop_table.error_reported

        if _error_reported:
            self.ui.table.blockSignals(False)
            return

        _pop_back_wdg = PopulateBackgroundWidgets(parent=self)
        _pop_back_wdg.run()
        self.name_search_clicked()

        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()

        o_undo = UndoHandler(parent=self)
        o_undo.save_table(first_save=True)

        self.ui.table.blockSignals(False)

    def import_table_clicked(self):
        self.ui.table.blockSignals(True)

        _o_table = IdlTableHandler(parent=self)
        _o_table._import()
        self.name_search_clicked()

        o_undo = UndoHandler(parent=self)
        o_undo.save_table(first_save=True)

        self.ui.table.blockSignals(False)

    def export_table_clicked(self):
        _o_table = IdlTableHandler(parent=self)
        _o_table._export()

    def table_select_state_changed(self, state, row):
        _o_table_handler = TableHandler(parent=self)
        _o_table_handler.check_selection_status(state, row)

        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()
        _o_gui.define_new_ndabs_output_file_name()
        _o_gui.define_new_sum_scans_output_file_name()

    def name_search_clicked(self):
        o_table = IdlTableHandler(parent=self)
        o_table.name_search()

    def clear_name_search_clicked(self):
        o_table = IdlTableHandler(parent=self)
        self.ui.name_search.setText('')
        o_table.name_search()

    def check_step2_gui(self, row, column):
        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()

        _o_gui.step2_background_flag()
        _o_gui.step2_update_background_dropdown()

        if column == 1:
            o_pop = PopulateBackgroundWidgets(parent=self)
            o_pop.refresh_contain()

        o_undo = UndoHandler(parent=self)
        o_undo.save_table()

    # PDF

    def check_q_range(self):
        _o_gui = Step2GuiHandler(parent=self)
        _o_gui.check_gui()

    def hidrogen_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.hidrogen_clicked()

    def no_hidrogen_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.no_hidrogen_clicked()

    def yes_background_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.yes_background_clicked()

    def no_background_clicked(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.no_background_clicked()

    def background_combobox_changed(self, index):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.background_index_changed(row_index=index)

    def reset_q_range(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.reset_q_range()

    def run_ndabs_clicked(self):
        o_create_sample_files = CreateSampleFiles(parent=self)
        o_create_sample_files.run()

        list_sample_files = o_create_sample_files.list_sample_files

        o_create_ndsum_file = CreateNdsumFile(parent=self)
        o_create_ndsum_file.run()

        o_run_ndsum = RunNDabs(parent=self, list_sample_files=list_sample_files)
        o_run_ndsum.run()

    def check_fourier_filter_widgets(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def check_plazcek_widgets(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def table_right_click(self, position):
        _o_table = IdlTableHandler(parent=self)
        _o_table.right_click(position=position)

    def run_sum_scans_clicked(self):
        o_run_sum_scans = RunSumScans(parent=self)
        o_run_sum_scans.run()

    def output_file_name_changed(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def pdf_qmax_line_edit_changed(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def sum_scans_output_file_name_changed(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def help_button_clicked_ndabs(self):
        self.help_button_clicked(button_name='ndabs')

    def help_button_clicked_scans(self):
        self.help_button_clicked(button_name='scans')

    # Rietveld

    def mantid_browse_calibration_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent=self)
        o_mantid_gui.browse_file(type='calibration')

    def mantid_browse_characterization_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent=self)
        o_mantid_gui.browse_file(type='characterization')

    def mantid_output_directory_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent=self)
        o_mantid_gui.browse_folder()

    def do_mantid_run_reduction(self):
        o_mantid_run = GlobalMantidReduction(parent=self)
        o_mantid_run.run()

    def check_mantid_gui(self):
        o_gui = Step2GuiHandler(parent=self)
        o_gui.check_gui()

    def help_button_clicked_mantid(self):
        self.help_button_clicked(button_name='mantid')

    # Mantid

    # master table
    def personalization_table_clicked(self):
        o_master_table_tree = TableTreeHandler(parent=self)
        _table_config = TableConfig(parent=self)
        current_config = _table_config.get_current_config()
        _table_config.update_tree_dict_and_tree(config_to_load=current_config)

    def closeEvent(self, c):
        if self.advanced_window_ui:
            self.advanced_window_ui.closeEvent(c)
        if self.make_calibration_ui:
            self.make_calibration_ui.closeEvent(c)
        if self.table_tree_ui:
            self.table_tree_ui.closeEvent(c)

    # events of the table and the tree

    def table_search(self, text):
        o_table = MtdTableHandler(parent=self)
        o_table.search(text)

    def table_search_clear(self):
        o_table = MtdTableHandler(parent=self)
        o_table.clear_search()

    def load_this_config(self, key='', resize=False):
        if key == '':
            return

        if key == 'FULL_RESET':
            config_to_load = self.reset_config_dict['table']
        else:
            config_to_load = self.config_dict[key]['table']

        h1_dict = config_to_load['h1']
        h2_dict = config_to_load['h2']
        h3_dict = config_to_load['h3']

        o_table = TableConfig(parent=self)
        o_table.disconnect_table_ui()

        for _col in h1_dict:
            _visible = h1_dict[_col]['visible']
            _width = h1_dict[_col]['width']
            o_table.set_size_and_visibility_column(h1=_col, width=_width, visibility=_visible, resize=resize)

        for _col in h2_dict:
            _visible = h2_dict[_col]['visible']
            _width = h2_dict[_col]['width']
            o_table.set_size_and_visibility_column(h2=_col, width=_width, visibility=_visible, resize=resize)

        for _col in h3_dict:
            _visible = h3_dict[_col]['visible']
            _width = h3_dict[_col]['width']
            o_table.set_size_and_visibility_column(h3=_col, width=_width, visibility=_visible, resize=resize)

        o_table.update_tree_dict_and_tree(config_to_load)

        o_table.disconnect_table_ui(unblock_all=True)

    def h3_table_right_click(self, position):
        o_h3_table = H3TableHandler(parent=self)
        o_h3_table.right_click()

    def check_status_of_right_click_buttons(self):
        o_h3_table = H3TableHandler(parent=self)
        o_h3_table.check_status_of_right_click_buttons()

    def scroll_h1_table(self, value):
        self.ui.h2_table.horizontalScrollBar().setValue(value)
        self.ui.h3_table.horizontalScrollBar().setValue(value)

    def scroll_h2_table(self, value):
        self.ui.h1_table.horizontalScrollBar().setValue(value)
        self.ui.h3_table.horizontalScrollBar().setValue(value)

    def scroll_h3_table(self, value):
        self.ui.h1_table.horizontalScrollBar().setValue(value)
        self.ui.h2_table.horizontalScrollBar().setValue(value)

    def resizing_h1(self, index_column, old_size, new_size):

        o_table = TableConfig(parent=self)
        o_table.disconnect_table_ui()

        h2_children = o_table.get_h2_children_from_h1(h1=index_column)
        last_h2_visible = o_table.get_last_h2_visible(list_h2=h2_children)
        list_h3 = o_table.get_h3_children_from_h2(h2=last_h2_visible)
        last_h3_visible = o_table.get_last_h3_visible(list_h3=list_h3)

        size_diff = new_size - old_size

        # add this size_diff to last_h2 and last_h3
        last_h3_visible_size = o_table.get_size_column(h3=last_h3_visible)
        if (last_h3_visible_size < self.minimum_col_width) and \
                (new_size < old_size):
            o_table.set_size_column(h1=index_column, width=old_size)
        else:
            last_h2_visible_size = o_table.get_size_column(h2=last_h2_visible)
            o_table.set_size_column(h2=last_h2_visible, width=last_h2_visible_size + size_diff)
            o_table.set_size_column(h3=last_h3_visible, width=last_h3_visible_size + size_diff)

        o_table.disconnect_table_ui(unblock_all=True)

    def resizing_h2(self, index_column, old_size, new_size):

        o_table = TableConfig(parent=self)
        o_table.disconnect_table_ui()

        h1_parent = o_table.get_h1_parent_from_h2(h2=index_column)
        h3_children = o_table.get_h3_children_from_h2(h2=index_column)
        last_h3_visible = o_table.get_last_h3_visible(list_h3=h3_children)

        size_diff = new_size - old_size

        last_h3_visible_size = o_table.get_size_column(h3=last_h3_visible)
        if (last_h3_visible_size < self.minimum_col_width) and \
                (new_size < old_size):
            o_table.set_size_column(h2=index_column, width=old_size)
        else:
            # add this size_diff to parent and last h3
            parent_size = o_table.get_size_column(h1=h1_parent)
            o_table.set_size_column(h1=h1_parent, width=parent_size + size_diff)
            o_table.set_size_column(h3=last_h3_visible, width=last_h3_visible_size + size_diff)

        o_table.disconnect_table_ui(unblock_all=True)

    def resizing_h3(self, index_column, old_size, new_size):

        o_table = TableConfig(parent=self)
        o_table.disconnect_table_ui()

        [h1_parent, h2_parent] = o_table.get_h1_h2_parent_from_h3(h3=index_column)

        size_diff = new_size - old_size

        h1_parent_size = o_table.get_size_column(h1=h1_parent)
        o_table.set_size_column(h1=h1_parent, width=h1_parent_size + size_diff)
        h2_parent_size = o_table.get_size_column(h2=h2_parent)
        o_table.set_size_column(h2=h2_parent, width=h2_parent_size + size_diff)

        o_table.disconnect_table_ui(unblock_all=True)

    def init_widgets(self):
        pass

    def init_tree(self):
        # fill the self.ui.treeWidget
        # self.addItems(self.ui.treeWidget.invisibleRootItem())
        self.addItems(self.ui.treeWidget.invisibleRootItem())
        self.ui.treeWidget.itemChanged.connect(self.tree_item_changed)

    def tree_item_changed(self, item, _):
        """this will change the way the big table will look like by hidding or showing columns"""

        o_table = TableConfig(parent=self)
        o_table.block_table_header_ui(block_all=False,
                                      block_h1=True,
                                      block_h2=True)

        h_columns_affected = o_table.get_h_columns_from_item_name(item_name=o_table.get_item_name(item))

        o_table.change_state_tree(list_ui=h_columns_affected['list_tree_ui'],
                                  list_parent_ui=h_columns_affected['list_parent_ui'],
                                  state=item.checkState(0))

        o_table.update_table_columns_visibility()
        o_table.resizing_table(tree_dict=h_columns_affected, block_ui=False)

        o_table.block_table_header_ui(unblock_all=True)

    # widgets from master table
    def master_table_select_state_changed(self, state, key):
        o_table = TableRowHandler(parent=self)
        o_table.activated_row_changed(key=key, state=state)

    ## sample columns
    def master_table_sample_material_button_pressed(self, key):
        MaterialHandler(parent=self, key=key, data_type='sample')

    def master_table_sample_material_line_edit_entered(self, key):
        o_table = TableRowHandler(parent=self)
        o_table.transfer_widget_states(from_key=key, data_type='sample')

    def master_table_sample_mass_density_button_pressed(self, key):
        MassDensityHandler(parent=self, data_type='sample', key=key)

    def master_table_sample_mass_density_line_edit_entered(self, key):
        o_table = TableRowHandler(parent=self)
        o_table.transfer_widget_states(from_key=key, data_type='sample')

    def master_table_sample_shape_changed(self, index, key):
        o_table = TableRowHandler(parent=self)
        o_table.shape_changed(shape_index=index, key=key, data_type='sample')

    def master_table_sample_abs_correction_changed(self, text, key):
        o_table = TableRowHandler(parent=self)
        o_table.abs_correction_changed(value=text, key=key, data_type='sample')

    def master_table_sample_multi_scattering_correction_changed(self, text, key):
        o_table = TableRowHandler(parent=self)
        o_table.multi_scattering_correction(value=text, key=key, data_type='sample')

    def master_table_sample_inelastic_correction_changed(self, text, key):
        o_table = TableRowHandler(parent=self)
        o_table.inelastic_correction_changed(value=text, key=key, data_type='sample')

    def master_table_sample_placzek_button_pressed(self, key):
        o_table = TableRowHandler(parent=self)
        o_table.placzek_button_pressed(key=key, data_type='sample')

    def master_table_sample_dimensions_setter_button_pressed(self, key):
        o_dimensions_ui = DimensionsSetter(parent=self, key=key, data_type='sample')
        o_dimensions_ui.show()

    # normalization columns
    def master_table_normalization_material_button_pressed(self, key):
        MaterialHandler(parent=self, key=key, data_type='normalization')

    def master_table_normalization_material_line_edit_entered(self, key):
        o_table = TableRowHandler(parent=self)
        o_table.transfer_widget_states(from_key=key, data_type='normalization')

    def master_table_normalization_mass_density_button_pressed(self, key):
        MassDensityHandler(parent=self, data_type='normalization', key=key)

    def master_table_normalization_mass_density_line_edit_entered(self, key):
        o_table = TableRowHandler(parent=self)
        o_table.transfer_widget_states(from_key=key, data_type='normalization')

    def master_table_normalization_shape_changed(self, text, key):
        o_table = TableRowHandler(parent=self)
        o_table.shape_changed(shape_index=text, key=key, data_type='normalization')

    def master_table_normalization_abs_correction_changed(self, text, key):
        o_table = TableRowHandler(parent=self)
        o_table.abs_correction_changed(value=text, key=key, data_type='normalization')

    def master_table_normalization_multi_scattering_correction_changed(self, text, key):
        o_table = TableRowHandler(parent=self)
        o_table.multi_scattering_correction(value=text, key=key, data_type='normalization')

    def master_table_normalization_inelastic_correction_changed(self, text, key):
        o_table = TableRowHandler(parent=self)
        o_table.inelastic_correction_changed(value=text, key=key, data_type='normalization')

    def master_table_normalization_placzek_button_pressed(self, key):
        o_table = TableRowHandler(parent=self)
        o_table.placzek_button_pressed(key=key, data_type='normalization')

    def master_table_normalization_dimensions_setter_button_pressed(self, key):
        o_dimensions_ui = DimensionsSetter(parent=self, key=key, data_type='normalization')
        o_dimensions_ui.show()

    def launch_import_from_database_handler(self):
        if ONCAT_ENABLED:
            ImportFromDatabaseHandler(parent=self)
        else:
            print('oncat functionality disabled')

    def launch_import_from_run_number_handler(self):
        ImportFromRunNumberHandler(parent=self)

    # def master_table_input_grouping_button_pressed(self, key):
    #     o_table = TableRowHandler(parent=self)
    #     o_table.grouping_button(key=key, grouping_type='input')
    #
    # def master_table_output_grouping_button_pressed(self, key):
    #     o_table = TableRowHandler(parent=self)
    #     o_table.grouping_button(key=key, grouping_type='output')

    # calibrations
    def make_calibration_clicked(self):
        MakeCalibrationLauncher(parent=self)

    def browse_calibration_clicked(self):
        _calibration_folder = self.calibration_folder
        [_calibration_file, ext] = QFileDialog.getOpenFileName(parent = self,
                                                               caption = "Select Calibration File",
                                                               directory = _calibration_folder,
                                                               filter = self.calibration_extension)
        if _calibration_file:
            self.ui.calibration_file.setText(_calibration_file)

    def from_oncat_to_master_table(self, json=None, with_conflict=False, ignore_conflicts=False):
        if self.import_from_database_ui:
            self.import_from_database_ui.close()

        LoadIntoMasterTable(parent=self, json=json,
                            with_conflict=with_conflict,
                            ignore_conflicts=ignore_conflicts)

    def apply_clicked(self):
        # do stuff
        self.close()

    def cancel_clicked(self):
        self.close()

    def _load_ascii(self, filename=''):
        o_ascii_loader = AsciiLoader(parent=self, filename=filename)
        o_ascii_loader.load()

    def reduction_configuration_button_clicked(self):
        ReductionConfigurationHandler(parent=self)


def main(mode):
    app = QApplication(sys.argv)
    app.setOrganizationName("Qtrac Ltd.")
    app.setOrganizationDomain("qtrac.eu")
    app.setApplicationName("Image Changer")
    app.setWindowIcon(QIcon(":/icon.png"))
    form = MainWindow(processing_mode=mode)
    form.show()
    app.exec_()

if __name__ == '__main__':
    import argparse  # noqa
    parser = argparse.ArgumentParser(description='ADvanced DIffraction Environment')
    parser.add_argument('--version', action='version', version='%(prog)s version {}'.format(__version__))
    parser.add_argument('--mode', type=str, default='mantid',
			help='Set processing mode (default=%(default)s)', choices=['mantid', 'idl'])

    try:
        # set up bash completion as a soft dependency
        import argcomplete  # noqa
        argcomplete.autocomplete(parser)
    except ImportError:
        pass  # silently skip this

    # parse the command line options
    options = parser.parse_args()

    # start the main program
    main(options.mode)
